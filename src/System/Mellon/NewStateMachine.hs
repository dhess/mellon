{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE TemplateHaskell #-}

-- | A 'MonadFree' implementation of the @mellon@ state machine.
--
-- Typically, a user process does not interact directly with a
-- 'StateMachine'. That is the job of a
-- 'System.Mellon.Controller.Controller'.
--
-- Generally speaking, you will only need to use 'StateMachine' if
-- you're implementing a 'System.Mellon.Controller.Controller'.
--
-- 'System.Mellon.Controller.Controller's invoke 'runStateMachine'
-- when they receive a user command, or when a scheduled lock command
-- fires. 'runStateMachine' figures out what should happen in response
-- to the command according to the @mellon@ 'StateMachine' model,
-- calls back into the 'System.Mellon.Controller.Controller' via the
-- 'StateMachineF' eDSL, and returns the new 'State'.
--
-- The @mellon@ state machine model is shown in the following diagram:
--
-- <mellon-state-diagram.png (local copy of state diagram)>
--
-- Note that the state machine model as implemented by 'StateMachine'
-- is slightly different than the one shown in the diagram.
-- Specificaly, there is a difference between the 'LockNowCmd' and
-- 'LockCmd' commands that is not represented in the state diagram,
-- which only shows a single "lock" command. This is due to the fact
-- that, in a concurrent implementation of a
-- 'System.Mellon.Controller.Controller', it may not be possible (let
-- alone performant) to guarantee that the
-- unlock-expiration-followed-by-lock sequence is atomic: the
-- controller could receive a new unlock command from the user while
-- it is arranging for the previously-scheduled lock to fire. In this
-- case, the controller needs to distinguish between a synchronous
-- lock command (i.e., a user request, which is always executed) and
-- an asynchronous lock command (i.e., generated by an expiring unlock
-- command, and to be ignored if, by the time it is received, a new
-- unlock command is already in progress). 'LockNowCmd' corresponds to
-- the former, while 'LockCmd' corresponds to the latter.
--
-- (The state machine shown in the state diagram is implicitly atomic
-- as it does not attempt to represent the flow of time, therefore it
-- only needs the one lock command type.)

module System.Mellon.NewStateMachine
         ( Cmd(..)
         , StateMachine
         , StateMachineF(..)
         , State(..)
         , stateMachine
         ) where

import Control.Monad.Free (liftF, Free, MonadFree)
import Control.Monad.Free.TH (makeFreeCon)
import Data.Time (UTCTime)

-- | The states of a @mellon@ 'StateMachine'. Note that a
-- 'System.Mellon.Controller.Controller' instance may have additional
-- state for internal bookkeeping (e.g., scheduled lock commands), but
-- these are not relevant to the pure 'StateMachine' model.
data State
  = Locked
  | Unlocked UTCTime
  deriving (Eq)

-- | The pure 'StateMachine' commands. These represent the transitions
-- from one state to the next.
data Cmd
    -- | Lock immediately, canceling any unlock currently in effect.
  = LockNowCmd
    -- | Lock in response to an expiring unlock. The unlock's
    -- expiration date is given by the specified 'UTCTime' timestamp.
    -- Note that this command is only ever issued directly by a
    -- 'System.Mellon.Controller.Controller', never by the user. A
    -- controller implementation must not expose this command to its
    -- users.
  | LockCmd UTCTime
    -- | Unlock until the specified time. If no existing unlock
    -- command with a later expiration is currently in effect, the
    -- 'System.Mellon.Controller.Controller' managing the state
    -- machine will automatically schedule a 'LockCmd' to run when
    -- this unlock expires.
  | UnlockCmd UTCTime
  deriving (Eq)

-- | The 'StateMachine' eDSL. Each 'System.Mellon.Controller.Controller'
-- instance provides an implementation of the eDSL which turns the
-- `StateMachine`'s pure state transformations into real-world
-- actions.
data StateMachineF next where
  Lock :: next -> StateMachineF next
  ScheduleLock :: UTCTime -> next -> StateMachineF next
  Unlock :: next -> StateMachineF next
  UnscheduleLock :: next -> StateMachineF next
  WaitForCmd :: (Cmd -> next) -> StateMachineF next

instance Functor StateMachineF where
  fmap f (Lock x) = Lock (f x)
  fmap f (ScheduleLock d x) = ScheduleLock d (f x)
  fmap f (Unlock x)  = Unlock (f x)
  fmap f (UnscheduleLock x) = UnscheduleLock (f x)
  fmap f (WaitForCmd g) = WaitForCmd (f . g)

-- | 'StateMachine' represented as a 'Free' monad.
type StateMachine = Free StateMachineF

makeFreeCon 'Lock
makeFreeCon 'Unlock
makeFreeCon 'ScheduleLock
makeFreeCon 'UnscheduleLock
makeFreeCon 'WaitForCmd

-- | The pure 'StateMachine' interpreter.
--
-- 'runStateMachine' provides an abstract, pure model of the core
-- @mellon@ state machine. The state machine is the same for all
-- implementations; what changes from one implementation to the next
-- is the specific machinery for locking and scheduling, which is
-- provided by a 'System.Mellon.Controller.Controller' instance.
stateMachine :: State -> StateMachine ()
stateMachine = loop
  where loop state =
          do cmd <- waitForCmd
             newState <- execCmd cmd state
             loop newState

execCmd :: Cmd -> State -> StateMachine State

execCmd LockNowCmd Locked = return Locked
execCmd LockNowCmd (Unlocked _) =
  do unscheduleLock
     lock
     return Locked

execCmd (LockCmd _) (Locked) = return Locked
execCmd (LockCmd lockDate) (Unlocked untilDate) =
  -- Only execute the lock command if its date matches the current
  -- outstanding unlock request's expiration date, i.e., if the lock
  -- command is the one that was scheduled by the current outstanding
  -- unlock request.
  --
  -- If the lock command's date does not match the current outstanding
  -- lock request's date, there are 2 possible cases:
  --
  -- 1. The lock command's date is earlier than the current
  -- outstanding unlock's expiration date. This means that the lock
  -- command's corresponding unlock command was overridden by a
  -- subsequent unlock with a later expiration date before the lock
  -- command fired, hence the state machine should ignore this lock
  -- command.
  --
  -- 2. The lock command's date is later than the current outstanding
  -- unlock's expiration date. You might think this should never
  -- happen, and indeed for a controller implementation that does
  -- strict bookkeeping and actually bothers to "unschedule" scheduled
  -- locks when a "lock now" command is received, it is extremely
  -- unlikely to occur... but I believe that for certain threaded
  -- controller implementations, it probably could, theoretically.
  -- Regardless, there's no harm in simply ignoring the request, as
  -- whatever unlock command is currently in progress, eventually it
  -- will either be canceled, or its own scheduled lock command will
  -- fire, in which case the dates will match exactly and everything
  -- will behave as expected.
  --
  -- In either case (1 or 2), the right thing to do is to ignore the
  -- lock command. The only question that remains is whether to treat
  -- case 2 as an error. For some very strict implementations, it's
  -- possible that it could be a real error, but I suspect that for
  -- most implementations, it's a very unlikely but probably harmless
  -- occurrence. That's how we treat it here.
  if lockDate == untilDate
     then lock >> return Locked
     else return (Unlocked untilDate)

execCmd (UnlockCmd untilDate) Locked = unlockUntil untilDate
execCmd (UnlockCmd untilDate) (Unlocked scheduledDate) =
  if untilDate > scheduledDate
     then unlockUntil untilDate
     else return $ Unlocked scheduledDate

unlockUntil :: UTCTime -> StateMachine State
unlockUntil date =
  do scheduleLock date
     unlock
     return $ Unlocked date
