{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE TemplateHaskell #-}

-- | A 'MonadFree' monad implementation of the @mellon@ state machine.
-- Both a 'Control.Monad.Free.Free' and a 'FreeT' monad transformer
-- implementation are provided.
--
-- Typically, a user process does not interact directly with a
-- 'StateMachine'. That is the job of a controller. Generally
-- speaking, you will only need to use 'StateMachine' if you're
-- implementing a 'System.Mellon.Controller'.
--
-- The @mellon@ state machine model is shown in the following diagram:
--
-- <mellon-state-diagram.png (local copy of state diagram)>
--
-- Note that the state machine model as implemented by 'StateMachine'
-- is slightly different than the one shown in the diagram.
-- Specificaly, there is a difference between the 'LockNowCmd' and
-- 'LockCmd' commands that is not represented in the state diagram,
-- which only shows a single "lock" command. This is due to the fact
-- that, in a concurrent implementation of a
-- 'System.Mellon.Controller' (e.g.,
-- 'System.Mellon.Controller.Concurrent'), it may not be possible (let
-- alone performant) to guarantee that the
-- unlock-expiration-followed-by-lock sequence is atomic: the
-- controller could receive a new unlock command from the user while
-- it is arranging for the previously-scheduled lock to fire. In this
-- case, the controller needs to distinguish between a synchronous
-- lock command (i.e., a user request, which is always executed) and
-- an asynchronous lock command (i.e., generated by an expiring unlock
-- command, and to be ignored if, by the time it is received, a new
-- unlock command is already in progress). 'LockNowCmd' corresponds to
-- the former, while 'LockCmd' corresponds to the latter.
--
-- (The state machine shown in the state diagram is implicitly atomic
-- as it does not attempt to represent the flow of time, therefore it
-- only needs the one lock command type.)

module System.Mellon.StateMachine
         ( Cmd(..)
         , StateMachine
         , StateMachineF(..)
         , StateMachineT
         , State(..)
         , stateMachineT
         ) where

import Control.Monad.Trans.Class (lift)
import Control.Monad.Trans.Free (FreeT, MonadFree, liftF)
import Control.Monad.Free.TH (makeFreeCon)
import Data.Functor.Identity (Identity)
import Data.Time (UTCTime)
import System.Mellon.Lock.Class

-- | The states of a @mellon@ 'StateMachine'. Note that a
-- 'System.Mellon.Controller' implementation may have additional state
-- for internal bookkeeping (e.g., scheduled lock commands), but these
-- are not relevant to the pure 'StateMachine' model.
data State
  = Locked
  | Unlocked UTCTime
  deriving (Eq)

-- | The 'StateMachine' commands. These represent the transitions
-- from one state to the next.
data Cmd
    -- | Lock immediately, canceling any unlock currently in effect.
  = LockNowCmd
    -- | Lock in response to an expiring unlock. The unlock's
    -- expiration date is given by the specified 'UTCTime' timestamp.
    -- Note that this command is only ever issued directly by a
    -- 'System.Mellon.Controller', never by the user.
  | LockCmd UTCTime
    -- | Quit the state machine. Note that this command is only ever
    -- issued directly by a 'System.Mellon.Controller', never by the
    -- user.
  | QuitCmd
    -- | Unlock until the specified time. If no existing unlock
    -- command with a later expiration is currently in effect, the
    -- 'System.Mellon.Controller' managing the state machine will
    -- automatically schedule a 'LockCmd' to run when this unlock
    -- expires.
  | UnlockCmd UTCTime
  deriving (Eq)

-- | The 'StateMachine' eDSL. A 'System.Mellon.Controller'
--  provides an implementation of the eDSL which turns the
-- `StateMachine`'s pure state transformations into real-world
-- actions.
data StateMachineF next where
  Halt :: StateMachineF next
  ScheduleLock :: UTCTime -> next -> StateMachineF next
  UnscheduleLock :: next -> StateMachineF next
  WaitForCmd :: (Cmd -> next) -> StateMachineF next

instance Functor StateMachineF where
  fmap _ Halt = Halt
  fmap f (ScheduleLock d x) = ScheduleLock d (f x)
  fmap f (UnscheduleLock x) = UnscheduleLock (f x)
  fmap f (WaitForCmd g) = WaitForCmd (f . g)

-- | A 'FreeT' monad transformer version of the @mellon@ state
-- machine.
type StateMachineT = FreeT StateMachineF

instance (MonadLock m) => MonadLock (FreeT StateMachineF m) where
  lock = lift lock
  unlock = lift unlock

-- | The basic @mellon@ state machine monad. Most
-- 'System.Mellon.Controller' implementations will use this version.
type StateMachine = StateMachineT Identity

makeFreeCon 'Halt
makeFreeCon 'ScheduleLock
makeFreeCon 'UnscheduleLock
makeFreeCon 'WaitForCmd

-- | The pure 'StateMachine' interpreter.
--
-- 'stateMachineT' provides an abstract, pure model of the core
-- @mellon@ state machine. The state machine is the same for all
-- implementations; what changes from one implementation to the next
-- is the specific machinery for locking and scheduling, which is
-- provided by a 'System.Mellon.Controller' implementation.
stateMachineT :: (MonadLock m) => State -> StateMachineT m a
stateMachineT = loop
  where loop state =
          do cmd <- waitForCmd
             case cmd of
               QuitCmd -> halt
               _ ->
                 do newState <- execCmdT cmd state
                    loop newState

execCmdT :: (MonadLock m) => Cmd -> State -> StateMachineT m State

-- Should never happen.
execCmdT QuitCmd _ = fail "execCmdT QuitCmd failed"

execCmdT LockNowCmd Locked = return Locked
execCmdT LockNowCmd (Unlocked _) =
  do unscheduleLock
     lock
     return Locked

execCmdT (LockCmd _) (Locked) = return Locked
execCmdT (LockCmd lockDate) (Unlocked untilDate) =
  -- Only execute the lock command if its date matches the current
  -- outstanding unlock request's expiration date, i.e., if the lock
  -- command is the one that was scheduled by the current outstanding
  -- unlock request.
  --
  -- If the lock command's date does not match the current outstanding
  -- lock request's date, there are 2 possible cases:
  --
  -- 1. The lock command's date is earlier than the current
  -- outstanding unlock's expiration date. This means that the lock
  -- command's corresponding unlock command was overridden by a
  -- subsequent unlock with a later expiration date before the lock
  -- command fired, hence the state machine should ignore this lock
  -- command.
  --
  -- 2. The lock command's date is later than the current outstanding
  -- unlock's expiration date. You might think this should never
  -- happen, and indeed for a controller implementation that does
  -- strict bookkeeping and actually bothers to "unschedule" scheduled
  -- locks when a "lock now" command is received, it is extremely
  -- unlikely to occur... but I believe that for certain threaded
  -- controller implementations, it probably could, theoretically.
  -- Regardless, there's no harm in simply ignoring the request, as
  -- whatever unlock command is currently in progress, eventually it
  -- will either be canceled, or its own scheduled lock command will
  -- fire, in which case the dates will match exactly and everything
  -- will behave as expected.
  --
  -- In either case (1 or 2), the right thing to do is to ignore the
  -- lock command. The only question that remains is whether to treat
  -- case 2 as an error. For some very strict implementations, it's
  -- possible that it could be a real error, but I suspect that for
  -- most implementations, it's a very unlikely but probably harmless
  -- occurrence. That's how we treat it here.
  if lockDate == untilDate
     then lock >> return Locked
     else return (Unlocked untilDate)

execCmdT (UnlockCmd untilDate) Locked = unlockUntilT untilDate
execCmdT (UnlockCmd untilDate) (Unlocked scheduledDate) =
  if untilDate > scheduledDate
     then unlockUntilT untilDate
     else return $ Unlocked scheduledDate

unlockUntilT :: (MonadLock m) => UTCTime -> StateMachineT m State
unlockUntilT date =
  do scheduleLock date
     unlock
     return $ Unlocked date
