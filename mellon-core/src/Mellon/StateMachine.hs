{-|
Module      : Mellon.StateMachine
Description : The @mellon-core@ state machine
Copyright   : (c) 2016, Drew Hess
License     : BSD3
Maintainer  : Drew Hess <src@drewhess.com>
Stability   : experimental
Portability : non-portable

The @mellon-core@ state machine model is shown in the following
diagram:

<<https://s3-us-west-2.amazonaws.com/mellon/mellon-state-diagram.svg mellon-core state diagram>>

Note that the state machine model implemented here is slightly
different than the one shown in the diagram. Specificaly, there is a
difference between the 'LockNowCmd' and 'LockCmd' commands that is not
represented in the state diagram, which only shows a single "lock"
command. This is due to the fact that, in a concurrent implementation
of a controller, it may not be possible to guarantee that the
unlock-expiration-followed-by-lock sequence is atomic: the controller
could receive a new unlock command from the user while it is arranging
for the previously-scheduled lock to fire. In this case, the
controller needs to distinguish between a synchronous lock command
(i.e., a user request, which is always executed) and an asynchronous
lock command (i.e., generated by an expiring unlock command, and to be
ignored if, by the time it is received, a new unlock command is
already in progress). 'LockNowCmd' corresponds to the former, while
'LockCmd' corresponds to the latter.

(The state machine shown in the state diagram is implicitly atomic
as it does not attempt to represent the flow of time, therefore it
only needs the one lock command type.)

-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE Safe #-}

module Mellon.StateMachine
       ( Input(..)
       , Output(..)
       , State(..)
       , transition
       ) where

import Data.Data
import Data.Time (UTCTime)
import GHC.Generics

-- | The machine's states.
data State
  = StateLocked
    -- ^ The state machine is in the locked state
  | StateUnlocked UTCTime
    -- ^ The state machine is unlocked until the specified time. If
    -- the time is in the past, then the machine is unlocked
    -- indefinitely.
  deriving (Eq,Show,Read,Generic,Data,Typeable)

-- | The machine's inputs, i.e., commands sent to the machine by a
-- controller.
data Input
  = InputLockNow
    -- ^ Lock immediately, canceling any unlock currently in effect
  | InputLock UTCTime
    -- ^ Lock in response to an expiring unlock. The unlock's
    -- expiration date is given by the specified 'UTCTime' timestamp.
    -- Note that in the @mellon-core@ protocol, these commands are
    -- only ever sent by the controller in response to an expired
    -- lock, and never by the user directly.
  | InputUnlock UTCTime
    -- ^ Unlock until the specified time. If no existing unlock
    -- command with a later expiration is currently in effect when
    -- this command is executed, the controller managing the state
    -- machine must schedule a 'LockInput' to run when this unlock
    -- expires.
  deriving (Eq,Show,Read,Generic,Data,Typeable)

-- | The machine's outputs, i.e., commands sent to a controller.
--
-- It's reasonable to wonder why the 'OutputUnlock' value takes a
-- 'UTCTime' parameter, when the 'State' its always associated with
-- ('StateUnlocked') also takes a 'UTCTime' parameter. Indeed, their
-- time values will always be the same. However, this redundancy
-- permits an interface to the state machine where the state is
-- implicit (e.g., in a state monad) and the controller only "sees"
-- the 'Output' (the controller needs to know when to schedule the
-- lock command).
data Output
  = OutputLock
    -- ^ Lock the device now
  | OutputUnlock UTCTime
    -- ^ Unlock the device now and schedule a lock to run at the given
    -- time.
  | OutputCancelLock
    -- ^ Cancel the currently scheduled lock and lock the device now
  deriving (Eq,Show,Read,Generic,Data,Typeable)

-- | Run one iteration of the state machine.
--
-- Note that some transitions require no action by the controller,
-- hence the first element of the returned pair (the 'Output' value)
-- is wrapped in 'Maybe'.
--
-- >>> import Data.Time.Clock (UTCTime(..), addUTCTime, secondsToDiffTime)
-- >>> import Data.Time.Calendar (fromGregorian)
-- >>> let zeroHour = UTCTime (fromGregorian 2016 06 02) 0
-- >>> let oneMinuteLater = 60 `addUTCTime` zeroHour
-- >>> let oneMinuteEarlier = (-60) `addUTCTime` zeroHour
-- >>> transition StateLocked InputLockNow
-- (Nothing,StateLocked)
-- >>> transition StateLocked (InputLock zeroHour)
-- (Nothing,StateLocked)
-- >>> transition StateLocked (InputUnlock zeroHour)
-- (Just (OutputUnlock 2016-06-02 00:00:00 UTC),StateUnlocked 2016-06-02 00:00:00 UTC)
-- >>> transition (StateUnlocked zeroHour) InputLockNow
-- (Just OutputCancelLock,StateLocked)
-- >>> transition (StateUnlocked zeroHour) (InputUnlock oneMinuteLater)
-- (Just (OutputUnlock 2016-06-02 00:01:00 UTC),StateUnlocked 2016-06-02 00:01:00 UTC)
-- >>> transition (StateUnlocked zeroHour) (InputUnlock zeroHour) -- no change
-- (Nothing,StateUnlocked 2016-06-02 00:00:00 UTC)
-- >>> transition (StateUnlocked zeroHour) (InputUnlock oneMinuteEarlier) -- use later expiration
-- (Nothing,StateUnlocked 2016-06-02 00:00:00 UTC)
-- >>> transition (StateUnlocked zeroHour) (InputLock zeroHour)
-- (Just OutputLock,StateLocked)
-- >>> transition (StateUnlocked zeroHour) (InputLock oneMinuteEarlier) -- only possible in a race condition
-- (Nothing,StateUnlocked 2016-06-02 00:00:00 UTC)
-- >>> transition (StateUnlocked zeroHour) (InputLock oneMinuteLater) -- should never happen, but handled gracefully anyway
-- (Nothing,StateUnlocked 2016-06-02 00:00:00 UTC)
transition :: State -> Input -> (Maybe Output, State)

-- Locked state transitions.
transition StateLocked InputLockNow            = (Nothing, StateLocked)
transition StateLocked (InputLock _)           = (Nothing, StateLocked)
transition StateLocked (InputUnlock untilDate) =
  (Just $ OutputUnlock untilDate,StateUnlocked untilDate)

-- Unlocked state transitions.
transition (StateUnlocked _) InputLockNow      = (Just OutputCancelLock, StateLocked)
transition (StateUnlocked scheduledDate) (InputUnlock untilDate) =
  if untilDate > scheduledDate
     then (Just $ OutputUnlock untilDate, StateUnlocked untilDate)
     else (Nothing, StateUnlocked scheduledDate)
transition (StateUnlocked scheduledDate) (InputLock lockDate) =
  -- In this case, the state machine is currently unlocked, and the
  -- controller is informing the state machine that a
  -- previously-scheduled lock event has fired; in other words, a
  -- previously-accepted unlock command has expired, and now it's time
  -- to lock the state machine again.
  --
  -- However, because of various race conditions between incoming
  -- asynchronous user commands and firing timer threads in the
  -- controller implementation, the state machine only act on the
  -- incoming lock command if its date matches the current state's
  -- "until date." If they match, then the incoming lock command
  -- "belongs" to the machine's current state, and the machine must
  -- heed it.
  --
  -- If the incoming lock command's date does /not/ match the current
  -- state's date, then there are 2 possible sub-cases:
  --
  -- 1. The lock command's date is /earlier/ than the current state's
  -- expiration date. This can only happen if the user sent a
  -- subsequent unlock command with a later expiration date, and the
  -- controller informed the state machine of the new request; but
  -- before the controller could cancel the earlier timer thread, that
  -- thread's timer expired and its lock command reached the state
  -- machine first.
  --
  -- 2. The lock command's date is /later/ than the current
  -- outstanding state's expiration date. This should probably never
  -- happen, but there might be an odd corner case that I'm not
  -- considering.
  --
  -- In case 1, the right thing to do is to ignore the lock command.
  -- The only question that remains is whether to treat case 2 as an
  -- error. The conservative thing to do would be to add an error
  -- state to the state machine, from which there is no recovery, but
  -- in the interest of keeping the controller robust in the face of
  -- errors, we simply ignore the lock command in this case, as well.
  if lockDate == scheduledDate
     then (Just OutputLock, StateLocked)
     else (Nothing, StateUnlocked scheduledDate)
